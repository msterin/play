/*
 * le.c. - latency emulation
 *
 * Gets latency distribution table  (more info below) and generates a sequence of
 * latencies  to comply with the distribution.
 *
 * it will be  to be called on IO completion in the kernel so it can
 * calculate the needed delay as "desiredLatency - acctualLatency".
 *
 * Assumptions and shortcuts:
 * - we assume the device is at least as fast as the desired latency profile
 * - if the latency is large than the desired one , we accept it and move on. We do not
 *      memorize it to adjust further outliners
 * - we assume that outliners (and general peaks) are spread randomly over time periods.
 *
 *
 * this code is to clean up the API and algorithm before moving it to the kernel
 * the "actual" latency here is faked by rand()
 *
 * (c) VMWare Inc, and Mark Sterin, 2017. under Apache v2 license
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>

// #include <rand.h>

/*
 Latency emulator.

 Used for calculating desired latency for Read and Write ops, based on latency distribution table.

 Usage: le <dist_table> <stats> <number_of_samples>

 The approach is to generate a uniform random index to access the distribution table.
 The distribution table has values providing the desired distribution.

 The distibution tables are explained in and generated by netem maketable
 https://github.com/shemminger/iproute2/tree/master/netem from
 actual samples collected on actual hardware we  want to emulate.
 (note: netem also provides a  few tables for distributions like normal and  pareto,
 so we can use it later if needed)
 The table assumes mean=0 and std_deviation=1 , so we'll also need to calculate and use
 correct values from actual samples using netem provided "stats" too.

*/



/*
 * Distr. table parse code. Taken from iproute2/tc/q_netem.c
 */
 #define MAX_DIST (16 * 1024)
 #define NETEM_DIST_SCALE	8192

 /*
 * Simplistic file parser for distrbution data.
 * Format is:
 *	  # comment line(s)
 *	  data0 data1 ...
 * data starts with a numeric.
 * Lines not starting with numberic are silently skipped
 */
 static int
 get_distribution(const char *name, int16_t *data, int maxdata)
 {
     FILE *f;
     int n;
     long x;
     size_t len;
     char *line = NULL;

     if ((f = fopen(name, "r")) == NULL) {
         fprintf(stderr, "No distribution data (%s: %s)\n",  name, strerror(errno));
         return -1;
     }

     n = 0;
     while (getline(&line, &len, f) != -1) {
         char *p, *endp;
         if (*line == '\n' || *line == '#' || isalpha(*line))
             continue;

         for (p = line; ; p = endp) {
             x = strtol(p, &endp, 0);
             if (endp == p)
                 break;

             if (n >= maxdata) {
                 fprintf(stderr, "%s: too much data\n", name);
                 n = -1;
                 goto error;
             }
             data[n++] = x;
         }
     }
  error:
     free(line);
     fclose(f);
     return n;
 }


/*
 * Simplistic parser for stats file.
 * File format:
 *    # comments...
 *    mu =      328.351351
 *    sigma =    38.548838
 *    rho =       1.000029
 * When 'rho' found, exists since rho is always the last.
 * returns 0 on success ,-1 if fails
 */
static int
get_stats(const char* name, uint32_t* mu, uint32_t* sigma,  uint32_t* rho)
{
    FILE *f;
    size_t len;
    char *line = NULL;
    char key[64]; // keys are short, 64 is more than enough

    if ((f = fopen(name, "r")) == NULL) {
        fprintf(stderr, "No stats data (%s: %s)\n",  name, strerror(errno));
        return -1;
    }
    while (getline(&line, &len, f) != -1) {
        char* endp;
        char* key;
        float val;
        if (*line == '\n' || *line == '#')
            continue;

        while (isspace(*line))  {
            line++;
        } // skip spaces

        key = line;                         // memorize key location
        while(isalpha(*line)) {
            line++;
        }                                   // skip key body
        *line++ = '\0';                     // null terminate the key
        while(isspace(*line) || *line == '=') {
            line++;
        } // skip to the value
        val = strtof(line, &endp);
        if (strcmp(key, "mu") == 0) {
            *mu = (uint32_t)val;
        } else if (strcmp(key, "sigma") == 0)  {
            *sigma = (uint32_t)val;
        } else if (strcmp(key, "rho") == 0) {
            *rho = (uint32_t)val;
            break;
        } else {
            fprintf(stderr, "Unknown key `%s`, skipping\n", key);
            return -1;
        }
    }
    fprintf(stderr, "Using mu, sigma, rho: %u %u %u\n", *mu, *sigma, *rho);
    fclose(f);
    return 0;
}

// based on /source/net/sched/sch_netem.c:tabledist()
static uint32_t
get_one_value(int16_t* dist_table, size_t dist_size,  uint32_t mu, uint32_t sigma) {
    long  x;
    long t;
    int32_t rnd;

    if (sigma == 0)
        return mu;

    /* default uniform distribution */
    if (dist_table == NULL) {
        return (rnd % (2*sigma)) - sigma + mu;
    }

    rnd = random();

    t = dist_table[rnd % dist_size];
    x = t * (sigma % NETEM_DIST_SCALE);
    if (x >= 0)
        x += NETEM_DIST_SCALE/2;
    else
        x -= NETEM_DIST_SCALE/2;

    return  x / NETEM_DIST_SCALE + (sigma / NETEM_DIST_SCALE) * t + mu;
}



// generates <count> of samples according to distribution data passed
static void
generate_latencies(int16_t* dist_data, size_t dist_size,  uint32_t mu, uint32_t sigma,  uint32_t rho, uint32_t count) {
    int i;
    for(i=0 ; i < count; i++) {
        int32_t val = get_one_value(dist_data, dist_size, mu, sigma);
        printf("%d\n", val);
    }
}


/*
 * read dist_table and stats, and then generate number_of_samples samples that follow distibiution
 * example:
 *   le fio.out.dist_tanle fio.out
 */

int
main(int argc, char* argv[]) {
    if (argc != 3) {
        printf("Usage: le <dist_table_file> <number_of_samples>\n");
        exit(2);
    }
    char *dist_file = argv[1];
    int count = atoi(argv[2]);


    /* read the stats (mean (mu), standard deviation (sigma), and correlation coefficient (rho))
     * to adjust the generated values */
     /* note: we do not use rho yet */
    uint32_t mu, sigma, rho;

    if (get_stats(dist_file, &mu, &sigma, &rho) != 0) {
        fprintf(stderr, "Failed to parse stats from %s", dist_file);
        exit(3);
    }

    // read the distr
    int16_t  *dist_data = NULL;
    size_t dist_size = 0;
    dist_data = calloc(sizeof(dist_data[0]), MAX_DIST);
    dist_size = get_distribution(dist_file, dist_data, MAX_DIST);
    if (dist_size <=0 ) {
        fprintf(stderr, "Failed to parse distribution table from %s\n", dist_file);
        exit(3);
    }

    generate_latencies(dist_data, dist_size, mu, sigma, rho, count);
    return 0;
}
